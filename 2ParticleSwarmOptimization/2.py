# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oQYAD8G2sDkx2Ze7BDcVZst7xv2loKX-

# 


---
"""

#from google.colab import drive
#drive.mount('/content/drive')

import numpy as np
import random
class Particle():
  def __init__(self, x_min, x_max, v_max, particle_id, objective_function, c1, c2):
    self.id = particle_id
    self.objective_function = objective_function
    self.c1 = c1  # cognative constant
    self.c2 = c2   # social constant
    
    self.x_min = x_min
    self.x_max = x_max
    self.v_max = v_max
      
    self.x = np.random.uniform(self.x_min ,self.x_max, 1) 
    self.fx = self.objective_function(self.x)
    

    self.v_next = 0

    
    self.personal_best_x =self.x
    self.personal_best_fx =self.fx
 
        
    # Something something Trajectory
    self.Trajectory_x=[self.x]
    self.Trajectory_fx=[self.fx]


  def get_particle_info_array(self):
    # Return array with [x, f(x), v_next, x_personal_best, f(x_personal_best)]
    return [self.x, self.fx, self.v_next, self.personal_best_x, self.personal_best_fx]


  def step(self, global_best_x):
    r1 = np.random.uniform(size=1 )
    r2 = np.random.uniform(size=1)
    w= 1

    #update the V_next 
    new_v = (w * self.x) +self.c1 * r1 * (self.personal_best_x- self.x) + self.c2 * r2 * (global_best_x-self.x)
    
    if new_v < self.v_max:
      self.v_next = new_v

    #update x and fx 
    self.x=self.x + self.v_next
    self.fx= self.objective_function(self.x)

    
    
    # evaluate f(x)
    if self.x< self.x_min:
      self.x= self.x_min
      self.fx= self.objective_function(self.x_min)
    if self.x>  self.x_max:
      self.x= self.x_max
      self.fx= self.objective_function(self.x_max)

    self.Trajectory_x.append(self.x)
    self.Trajectory_fx.append(self.fx)
     

    if  self.personal_best_fx > self.fx:
      self.personal_best_x =self.x
      self.personal_best_fx= self.fx

#vvv=Particle(2,10,19,1,objective_function,2,3)
#print(vvv.get_particle_info_array())

class PSO():
  def __init__(self, objective_function, N_particles, x_min, x_max, v_max, c1,c2 ):
    self.objective_function = objective_function
    self.nr_particles = N_particles
    self.x_min = x_min
    self.x_max = x_max
    self.v_max = v_max
    self.step_i = 0    # internal step counter
    self.swarm = []
    self.c1= c1
    self.c2=c2
    
    # Swarm creation
    for i in range(self.nr_particles):
      particle = Particle(objective_function=self.objective_function,x_min=self.x_min, x_max=self.x_max,v_max=self.v_max, c1=self.c1,  c2=self.c2, particle_id =i)
      self.swarm.append(particle)


    #set global best x and fx 
    self.global_best_x,  self.global_best_fx = self.get_current_best_x_and_fx()
       
    for particle in self.swarm:
      print(particle.x, particle.fx,particle.id ) 
    
  
  def visualize_swarm(self):
    #plotting our function from random functions 
    xt = np.linspace( self.x_min  , self.x_max , 1000)
    ob_y= self.objective_function(xt)
    plt.plot(xt, ob_y)
    
    #plotting the particles 
    for p in self.swarm :
      plt.scatter(p.x, p.fx )
      plt.text(p.x, p.fx+0.5, p.id)
    
    #specify the global best on graph
    #current_best_swarm_x, current_best_swarm_fx = self.get_current_best_x_and_fx()
    plt.scatter(self.global_best_x,  self.global_best_fx, marker='X', linewidths= 6 ,color='red')

    # title
    title_txt ='step: ' +  str(self.step_i)
    plt.title(title_txt)
    plt.ylabel('y=f(x)')
    plt.xlabel('x')
    plt.grid()
    plt.show()

  def plot_swarm_trajectory_graph(self, fig_width=15, fig_height=15):
    list_of_iters=np.arange(self.step_i+1)
    #print("list_of_iters",list_of_iters)
    list_of_x=[]


    plt.figure(figsize=(fig_width, fig_height))

    for i, particle in enumerate(self.swarm):
      list_of_x=np.array(particle.Trajectory_x)
      print(particle.Trajectory_x)#one particle 100 iterations value as list
      plt.plot(list_of_iters, list_of_x)

    plt.show()
      
    plt.title('Particle Trajectories')
    plt.xlabel('nr iterations')
    plt.ylabel('x_position')
    plt.hlines(y=self.global_best_x, xmin=-5, xmax=self.step_i, linestyles="--",color="red", linewidth=10)
    
   
    print("haha")
  


  def get_swarm_info_array(self):
    swarm_info_array = []
    for p in self.swarm:
      swarm_info_array.append(p.get_particle_info_array())
    return np.array(swarm_info_array)




  # update global best x and fx
  def get_current_best_x_and_fx(self):
    # current_best_fx_found_so_far = 10000 or self.swarm(i).fx
    # for each particle check its fx ->if particle.fx < current_best_fx?
    # if no -> move to next
    # if yes - > current_best_fx_so_far = particle.fx
    first_particle = self.swarm[0]
    current_best_fx_found_so_far = first_particle.fx
    current_best_x_found_so_far= self.swarm[0].x
    for par in self.swarm:
      if par.fx < current_best_fx_found_so_far:
        current_best_fx_found_so_far= par.fx
        current_best_x_found_so_far= par.x
        
    return current_best_x_found_so_far, current_best_fx_found_so_far

  #
  def step(self):
    self.step_i= self.step_i+1
    for parti in self.swarm:
      parti.step(global_best_x = self.global_best_x)

    current_best_x, current_best_fx = self.get_current_best_x_and_fx()
    if  current_best_fx < self.global_best_fx:
      self.global_best_x= current_best_x
      self.global_best_fx=current_best_fx

    print(self.global_best_x, self.global_best_fx)
    
   
  def run(self, nr_steps):
    for i in range(nr_steps):
      self.step()
    return self.global_best_x, self.global_best_fx

import file_pso as assign2
import matplotlib.pyplot as plt


x_min =-0.0
x_max = 200.0
obj_f = assign2.generate_an_objective_function(x_min, x_max)
xt = np.linspace(x_min, x_max, 1000)
fx = obj_f(xt)
plt.plot(xt, fx)


my_pso_object = PSO(objective_function=obj_f, N_particles=1000, x_min=x_min, x_max=x_max, v_max=10.0, c1=1.0,c2=1.0)

my_pso_object.visualize_swarm()
my_pso_object.run(1000)
my_pso_object.visualize_swarm()
my_pso_object.plot_swarm_trajectory_graph()


'''
#### MAKE AN ANIMATION OF A PSO "SEARCH" #####
# You need a 'fresh' initial swarm. Otherwise not much interesting
# will happen in the animation when the swarm has settled

import file_pso as assign2
from file_pso import generate_1D_PSO_animation

# Init swarm
s = PSO(objective_function=obj_f, N_particles=10, x_min=2, x_max=200, v_max=4, c1=1.0,c2=1.0)

# now generate a 1d animation in the next cell


assign2.generate_1D_PSO_animation(s, N_iterations=200, file_name='1d_pso_animation')

'''